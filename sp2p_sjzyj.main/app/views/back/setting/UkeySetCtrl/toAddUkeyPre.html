#{extends 'common/back/settingMain.html' /}
	#{set title:'设置 | 加密狗设置' /}
	#{set smallclass:5 /}
	#{set crumbs:'设置>加密狗设置'/}
<div class="back-main">
	<!-- 头部筛选条件 -->
	<div class="back-usertop">
		<div class="left back-usermenu">
			<a href="javascript:void(0)" class="selected">加密锁添加</a>
		</div>
		
	</div>
	
	<div class="back-cont">
		<div class="back-infor">
			<form action="@{back.setting.UkeySetCtrl.addUkey()}" method="POST" id="sms">
				<h2 class="back-infor-head">
					<span class="left">设置写密码</span>
				</h2>
				<ul class="back-infor-set">
					<li>
						<span class="lileft">锁编号</span>
						<div class="liright">
							<input type="text" class="width01 iffocus" maxlength="64" name="ukeySn" value="${flash.ukeySn}" />
							<span class="back-text-limit">例如 : SN.0001</span>
						</div>
					</li>
					<li>
						<span class="lileft">锁ID</span>
						<div class="liright">
							<input type="text" class="width01 iffocus" id="getid" maxlength="64" name="ukeyId" value="${flash.ukeyId}" />
							<input type="button"   onclick="login_onclick()" value="获取" class="getid" >
						</div>
					</li>
					<li class="back-margin">
						<input type="submit" class="setup" value="添加">
					</li>
				</ul>
			</form>
		</div>
	</div>
</div>
	
<script type="text/javascript" src="/public/front/javascripts/Syunew3.js" ></script>
<script type="text/javascript">

	var bConnect = 0;
	
	window.onload=function() {
		//如果是IE10及以下浏览器，则跳过不处理
		if (navigator.userAgent.indexOf("MSIE") > 0 && !navigator.userAgent.indexOf("opera") > -1)
			return;
		try {
			var s_pnp = new SoftKey3W();
			s_pnp.Socket_UK.onopen = function() {
				bConnect = 1;//代表已经连接，用于判断是否安装了客户端服务
			}

			var a = 0;
			var b = 0;
			
			//在使用事件插拨时，注意，一定不要关掉Sockey，否则无法监测事件插拨
			s_pnp.Socket_UK.onmessage = function got_packet(Msg) {
				var PnpData = JSON.parse(Msg.data);
			
				if (PnpData.LastError == 0) {
					b == 1;
				}
				
				if (PnpData.type == "PnpEvent")//如果是插拨事件处理消息
				{
					if (PnpData.IsIn) {
						if (a == 0) {
							a = 1;
							b = 1;
							alert("UKEY已被插入");
						}
					} else {
						if (b == 1) {
							a = 0;
							b = 0;
							alert("UKEY已被拨出");
						}
					}
				}
			}

			s_pnp.Socket_UK.onclose = function() {

			}
		} catch (e) {
			alert(e.name + ": " + e.message);
			return false;
		}
	}
	var digitArray = new Array('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');

	function toHex( n ) {

	        var result = ''
	        var start = true;

	        for ( var i=32; i>0; ) {
	                i -= 4;
	                var digit = ( n >> i ) & 0xf;

	                if (!start || digit != 0) {
	                        start = false;
	                        result += digitArray[digit];
	                }
	        }

	        return ( result == '' ? '0' : result );
	}
	function login_onclick() 
	{
	    //如果是IE10及以下浏览器，则使用AVCTIVEX控件的方式
	    if(navigator.userAgent.indexOf("MSIE")>0 && !navigator.userAgent.indexOf("opera") > -1) return Handle_IE10();
	    
	    //判断是否安装了服务程序，如果没有安装提示用户安装
	    if(bConnect==0)
	    {
	        window.alert ( "未能连接服务程序，请确定服务程序是否安装。");return false;
	    }
		 try
		 {
				var DevicePath;
				var Count=0;//计数器,从0开始查找
				
			    //由于是使用事件消息的方式与服务程序进行通讯，
			    //好处是不用安装插件，不分系统及版本，控件也不会被拦截，同时安装服务程序后，可以立即使用，不用重启浏览器
			    //不好的地方，就是但写代码会复杂一些
				var s_simnew1=new SoftKey3W(); //创建UK类
				
			    s_simnew1.Socket_UK.onopen = function() {
			   	   s_simnew1.ResetOrder();//这里调用ResetOrder将计数清零，这样，消息处理处就会收到0序号的消息，通过计数及序号的方式，从而生产流程
			    } 

	            //写代码时一定要注意，每调用我们的一个UKEY函数，就会生产一个计数，即增加一个序号，较好的逻辑是一个序号的消息处理中，只调用我们一个UKEY的函数
			    s_simnew1.Socket_UK.onmessage =function got_packet(Msg) 
			    {
			        var UK_Data = JSON.parse(Msg.data);
			        if(UK_Data.type!="Process")return ;//如果不是流程处理消息，则跳过
			        switch(UK_Data.order) 
			        {
			            case 0:
			                {
			                    s_simnew1.FindPort(Count); //发送命令取UK的路径
			                }
			                break;//!!!!!重要提示，如果在调试中，发现代码不对，一定要注意，是不是少了break,这个少了是很常见的错误
			            case 1:
			                {
			                    if( UK_Data.LastError!=0)
			                    {
			                        if(Count<1)window.alert ( "未发现加密锁，请插入加密锁");
			                        s_simnew1.Socket_UK.close();
			                        console.log(Count)
			                        if(Count>1){
										window.alert ( "你插入了"+Count+"个加密锁请拔出其他加密锁再获取");
										return false;
									} else if(Count=1){
										login_onclicks();
									}
			                    } 
			                    DevicePath=UK_Data.return_value;//获得返回的UK的路径
			                    Count=Count+1;
			                   
			                    s_simnew1.ResetOrder();//Count加1后，重新开始查找
			                }
			                break;
	                }
			    } 
			    s_simnew1.Socket_UK.onclose = function(){
						
						
			    }
				return true;
		  }

		 catch(e)  
		  {  
			alert(e.name + ": " + e.message);
			return false;
		  }  

	}

	function Handle_IE10() 
	{

		 try
		 {
			var DevicePath;
			var Count=0;//计数器,从0开始查找
		    //创建控件
			s_simnew1=new ActiveXObject("Syunew3A.s_simnew3");

	        for (Count= 0; Count < 255;Count++)
	        {
			    DevicePath = s_simnew1.FindPort(Count);//'查找加密锁
			    if( s_simnew1.LastError!= 0 )
			    {
			        if(Count<1)window.alert ( "未发现加密锁，请插入加密锁");
			        return false;
				    window.alert ( "未发现加密锁，请插入加密锁");return false;
			    }
			    else
			    {
				     window.alert ( "已找到第"+Count+"加密锁");
	    				
			     }
			 }
			return true;
		 }

		 catch(e)  
		  {  
			alert(e.name + ": " + e.message);
			return false;
		  }  

	}

	
	
	
	
/*  */
function login_onclicks() 
{
    //如果是IE10及以下浏览器，则使用AVCTIVEX控件的方式
    if(navigator.userAgent.indexOf("MSIE")>0 && !navigator.userAgent.indexOf("opera") > -1) return Handle_IE10s();
    
    //判断是否安装了服务程序，如果没有安装提示用户安装
    if(bConnect==0)
    {
        window.alert ( "未能连接服务程序，请确定服务程序是否安装。");return false;
    }
	 try
	 {
		var DevicePath,mylen,ret,keyid,username,mykey,outstring,address,mydata,i,InString,versionex,version,seed;
		var ProduceDate,macAddr;
		
		
        //由于是使用事件消息的方式与服务程序进行通讯，
        //好处是不用安装插件，不分系统及版本，控件也不会被拦截，同时安装服务程序后，可以立即使用，不用重启浏览器
        //不好的地方，就是但写代码会复杂一些
        var s_simnew1=new SoftKey3W(); //创建UK类
			
		 s_simnew1.Socket_UK.onopen = function() {
	   	   s_simnew1.ResetOrder();//这里调用ResetOrder将计数清零，这样，消息处理处就会收到0序号的消息，通过计数及序号的方式，从而生产流程
	    } 
		    
		 //写代码时一定要注意，每调用我们的一个UKEY函数，就会生产一个计数，即增加一个序号，较好的逻辑是一个序号的消息处理中，只调用我们一个UKEY的函数
	    s_simnew1.Socket_UK.onmessage =function got_packet(Msg) 
	    {
	        var UK_Data = JSON.parse(Msg.data);
	        if(UK_Data.type!="Process")return ;//如果不是流程处理消息，则跳过
	        //alert(Msg.data);
	        switch(UK_Data.order) 
	        {
	            case 0:
	                {
	                    s_simnew1.FindPort(0);//查找加密锁
	                }
	                break;//!!!!!重要提示，如果在调试中，发现代码不对，一定要注意，是不是少了break,这个少了是很常见的错误
	            case 1:
	                {
	                    if( UK_Data.LastError!=0){window.alert ( "未发现加密锁，请插入加密锁");s_simnew1.Socket_UK.close();return false;} 
	                    DevicePath=UK_Data.return_value;//获得返回的UK的路径
	                    
				         s_simnew1.GetID_1(DevicePath); //'读取锁的ID
				    }
				    break;
				case 2:
				    {	
				        if( UK_Data.LastError!=0){window.alert("读取锁的ID时错误，错误码为："+UK_Data.LastError.toString());s_simnew1.Socket_UK.close();return false;}
				        keyid=toHex(UK_Data.return_value);
				        s_simnew1.GetID_2(DevicePath); //'读取锁的ID
				    }
				    break;
				case 3:
				    {	
				        if( UK_Data.LastError!=0){window.alert("读取锁的ID时错误，错误码为："+UK_Data.LastError.toString());s_simnew1.Socket_UK.close();return false;}
				        keyid=keyid+toHex(UK_Data.return_value);
				        $('#getid').val(keyid)
				    }
				    break;			
	            }
	     }
    	    
		 s_simnew1.Socket_UK.onclose = function(){

	     }
		 return true;
	 }

	 catch(e)  
	 {  
		alert(e.name + ": " + e.message);
		return false;
	 }  

}

function Handle_IE10s() 
{

	 try
	 {
			var DevicePath,mylen,ret,keyid,username,mykey,outstring,address,mydata,i,InString,versionex,version,seed;
            
            //建立操作我们的锁的控件对象，
		    s_simnew1=new ActiveXObject("Syunew3A.s_simnew3");

			DevicePath = s_simnew1.FindPort(0);//'查找加密锁
			//DevicePath = s_simnew1.FindPort_2(0,1,  70967193);//'查找指定的加密锁（使用普通算法）
			if( s_simnew1.LastError!= 0 )
			{
				window.alert ( "未发现加密锁，请插入加密锁");return false;
			}
			else
			{
				
		        {
		        //'读取锁的ID
                    keyid=toHex(s_simnew1.GetID_1(DevicePath))+toHex(s_simnew1.GetID_2(DevicePath));
                    if( s_simnew1.LastError!= 0 )
			        {
	                    window.alert( "获取ID错误,错误码是"+s_simnew1.LastError.toString());
		                return false;
			        }
			        window.alert ("锁的ID是："+keyid);
		        }
		 }
			return true;
	  }

	 catch(e)  
	  {  
		alert(e.name + ": " + e.message);
		return false;
	  }  

}
</script>

















